//! # Key Generation Utilities
//! Contains utilities for generating RSA keys.
//!
//! RSA Keys generated by this library are intended to be created via the `KeyPairBuilder`
//! object, which has various chainable methods one can use to specify various parameters during
//! key generation.

use num::{BigUint, Integer};
use num_bigint::RandBigInt;
use rand::{rngs::StdRng, CryptoRng, SeedableRng};

use crate::errors::{RsaError, RsaErrorKind}; //RsaOptionsError;
use crate::util::{carmichael_totient, generate_candidate_prime, generate_prime_local_search};

/// Each prime factor of RSA modulus `n` is 1024 bits in length.
pub const RSA_PRIME_NUMBER_BIT_LENGTH: u64 = 1024;

/// Each RSA modulus is `2048` bits in length.
pub const RSA_MODULUS_BIT_LENGTH: usize = 2048;

/// Defined in [RFC8017](https://www.rfc-editor.org/rfc/rfc8017)
///
/// Currently, this library only supports version 0, which means that each RSA modulus
/// `n = pq`; it is only the product of two primes.
pub const RSA_VERSION: u8 = 0;

/// The default number of miller-rabin primality tests to conduct
pub const DEFAULT_MR_ITERATIONS: usize = 1;

/// The method by which to generate primes
pub enum PrimeGenMethod {
    /// This method generates odd numbers at random until a number is found that passes the
    /// various rounds of Miller-Rabin primality testing.
    RandomGeneration,

    /// This method generates one odd number at random, then increments it until a number
    /// is found that passes the various rounds of Miller-Rabin primality testing.
    RandomizedLocalSearch,
    // Custom(F) ?
}

pub trait RsaCsprng: CryptoRng + RandBigInt {}
impl<T: CryptoRng + RandBigInt> RsaCsprng for T {}

/// An object used for constructing KeyPairs.
pub struct KeyPairBuilder {
    /// An optionally specified public exponent. A commonly chosen exponent for RSA is 65537.
    ///
    /// If `None` is provided, one will be calculated using the `rng` also defined in this struct.
    exponent: Option<BigUint>,

    /// An optionally specified RSA modulus, which is defined as a tuple of two primes `p, q`.
    ///
    /// If `None` is provided, these primes will be generated using the `rng`,
    /// the given `prime_generation_method`, and the number of `miller_rabin_iterations`
    /// also defined in this struct.
    modulus: Option<(BigUint, BigUint)>,

    /// An optionally specified [CSPRNG](https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator).
    ///
    /// If `None` is provided, `StdRng` from the `rand` crate will be used.
    rng: Option<Box<dyn RsaCsprng>>,

    /// The number of times to conduct the [Miller-Rabin Primality Test](https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test)
    /// during the generation of primes.
    ///
    /// By default, the number of iterations is `1` for quick key generation, but it's recommended to increase this value.
    miller_rabin_iterations: usize,

    /// The method by which to generate primes. See the `PrimeGenMethod` enum for more information.
    prime_generation_method: PrimeGenMethod,
    // private key representation
}

impl Default for KeyPairBuilder {
    fn default() -> Self {
        Self {
            exponent: None,
            modulus: None,
            rng: None,
            miller_rabin_iterations: DEFAULT_MR_ITERATIONS,
            prime_generation_method: PrimeGenMethod::RandomizedLocalSearch,
        }
    }
}

impl KeyPairBuilder {
    pub fn with_exponent(&mut self, e: BigUint) -> &mut Self {
        self.exponent = Some(e);
        self
    }
    pub fn with_modulus(&mut self, p: BigUint, q: BigUint) -> &mut Self {
        self.modulus = Some((p, q));
        self
    }
    pub fn with_rng(&mut self, rng: Box<dyn RsaCsprng>) -> &mut Self {
        self.rng = Some(rng);
        self
    }
    pub fn with_iterations(&mut self, iterations: usize) -> &mut Self {
        self.miller_rabin_iterations = iterations;
        self
    }
    pub fn with_prime_gen_method(&mut self, m: PrimeGenMethod) -> &mut Self {
        self.prime_generation_method = m;
        self
    }

    /// Consumes fields
    /// TODO:
    /// - smaller prime sieving (precomputed primes < 10,000?)
    /// - optimize bases for miller-rabin?
    /// - miller-rabin multithreading?
    pub fn create_keypair(&mut self) -> Result<KeyPair, RsaError> {
        let mut rng = self.rng.take().unwrap_or(Box::new(StdRng::from_entropy()));
        let mr_iterations = self.miller_rabin_iterations;

        let modulus = self
            .modulus
            .take()
            .unwrap_or_else(|| match &self.prime_generation_method {
                PrimeGenMethod::RandomGeneration => (
                    generate_candidate_prime(&mut rng, mr_iterations),
                    generate_candidate_prime(&mut rng, mr_iterations),
                ),
                PrimeGenMethod::RandomizedLocalSearch => (
                    generate_prime_local_search(&mut rng, mr_iterations),
                    generate_prime_local_search(&mut rng, mr_iterations),
                ),
                // PrimeGenMethod::Custom(f) => (f(&mut rng), f(&mut rng)),
            });

        let lambda = carmichael_totient(&modulus.0, &modulus.1);

        let exponent = self.exponent.take().unwrap_or_else(|| {
            // compute carmichael totient = lambda
            // look for values of e that are coprime to lambda
            let three = BigUint::ZERO + 3u32;
            let one = BigUint::ZERO + 1u32;
            let mut e = rng.gen_biguint_range(&three, &lambda);

            // pick a random spot, look locally till we find something coprime to lambda
            // if we reach lambda then start over
            // should be faster than just generating randomly over and over
            while e.gcd(&lambda) != one {
                e.inc();

                if e == lambda {
                    e = rng.gen_biguint_range(&three, &lambda);
                }
            }

            e
        });

        let secret = exponent.modinv(&lambda).ok_or_else(|| {
            RsaError::new(
                RsaErrorKind::RsaOptionsError,
                format!(
                    "unable to find modular inverse of {} with respect to {}.",
                    exponent, lambda
                ),
            )
        })?;

        let n = &modulus.0 * &modulus.1;

        let pk = RsaPublicKey::new(exponent.clone(), n.clone());
        let sk = RsaPrivateKey::with_values(n, exponent, secret, modulus.0, modulus.1)?;

        Ok(KeyPair {
            public_key: pk,
            private_key: sk,
        })
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct KeyPair {
    pub public_key: RsaPublicKey,
    pub private_key: RsaPrivateKey,
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct RsaPublicKey {
    pub modulus: BigUint,
    pub public_exponent: BigUint,
}

#[derive(Clone, Debug, Eq, PartialEq)]
/// [See source](https://datatracker.ietf.org/doc/html/rfc3447#appendix-A)
pub struct RsaPrivateKey {
    pub version: u8,
    pub modulus: BigUint,
    pub public_exponent: BigUint,
    pub private_exponent: BigUint,
    pub prime1: BigUint,
    pub prime2: BigUint,
    pub exponent1: BigUint,
    pub exponent2: BigUint,
    pub coefficient: BigUint,
}

impl RsaPublicKey {
    pub fn new(e: BigUint, n: BigUint) -> Self {
        Self {
            public_exponent: e,
            modulus: n,
        }
    }
}

impl RsaPrivateKey {
    pub fn new(
        version: u8,
        modulus: BigUint,
        public_exponent: BigUint,
        private_exponent: BigUint,
        prime1: BigUint,
        prime2: BigUint,
        exponent1: BigUint,
        exponent2: BigUint,
        coefficient: BigUint,
    ) -> Self {
        Self {
            version,
            modulus,
            public_exponent,
            private_exponent,
            prime1,
            prime2,
            exponent1,
            exponent2,
            coefficient,
        }
    }

    fn with_values(
        n: BigUint,
        e: BigUint,
        d: BigUint,
        p: BigUint,
        q: BigUint,
    ) -> Result<Self, RsaError> {
        let one = BigUint::ZERO + 1u32;
        let p1 = &p - 1u32;
        let q1 = &q - 1u32;

        let dp = d.modpow(&one, &p1);
        let dq = d.modpow(&one, &q1);
        let qinv = q.modinv(&p).ok_or_else(|| {
            RsaError::new(
                RsaErrorKind::RsaOptionsError,
                format!(
                    "Unable to compute modular inverse of {} with respect to {}.",
                    q, p
                ),
            )
        })?;

        Ok(Self {
            version: RSA_VERSION,
            modulus: n,
            public_exponent: e,
            private_exponent: d,
            prime1: p,
            prime2: q,
            exponent1: dp,
            exponent2: dq,
            coefficient: qinv,
        })
    }
}
