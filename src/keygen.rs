//! # Key Generation Utilities
//! Contains utilities for generating RSA keys.
//!
//! RSA Keys generated by this library are intended to be created via the `KeyPairBuilder`
//! object, which has various chainable methods one can use to specify various parameters during
//! key generation.

use num::{BigInt, Integer};
use num_bigint::RandBigInt;
use rand::{rngs::StdRng, CryptoRng, SeedableRng};

use crate::errors::{RsaError, RsaErrorKind}; //RsaOptionsError;
use crate::util::{carmichael_totient, generate_candidate_prime};

/// Each prime factor of RSA modulus `n` is 1024 bits in length.
pub const RSA_PRIME_NUMBER_BIT_LENGTH: u64 = 1024;

/// Each RSA modulus is `2048` bits in length.
pub const RSA_MODULUS_BIT_LENGTH: usize = 2048;

/// Defined in [RFC8017](https://www.rfc-editor.org/rfc/rfc8017)
///
/// Currently, this library only supports version 0, which means that each RSA modulus
/// `n = pq`; it is only the product of two primes.
pub const RSA_VERSION: u8 = 0;

/// The default number of miller-rabin primality tests to conduct
pub const DEFAULT_MR_ITERATIONS: usize = 10;

pub trait RsaCsprng: CryptoRng + RandBigInt {}
impl<T: CryptoRng + RandBigInt> RsaCsprng for T {}

/// An object used for constructing KeyPairs.
pub struct KeyPairBuilder {
    /// An optionally specified public exponent. A commonly chosen exponent for RSA is 65537.
    ///
    /// If `None` is provided, one will be calculated using the `rng` also defined in this struct.
    exponent: Option<BigInt>,

    /// An optionally specified RSA modulus, which is defined as a tuple of two primes `p, q`.
    ///
    /// If `None` is provided, these primes will be generated using the `rng`,
    /// the given `prime_generation_method`, and the number of `miller_rabin_iterations`
    /// also defined in this struct.
    modulus: Option<(BigInt, BigInt)>,

    /// An optionally specified [CSPRNG](https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator).
    ///
    /// If `None` is provided, `StdRng` from the `rand` crate will be used.
    rng: Option<Box<dyn RsaCsprng>>,

    /// The number of times to conduct the [Miller-Rabin Primality Test](https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test)
    /// during the generation of primes.
    ///
    /// By default, the number of iterations is `1` for quick key generation, but it's recommended to increase this value.
    miller_rabin_iterations: usize,
}

impl Default for KeyPairBuilder {
    fn default() -> Self {
        Self {
            exponent: None,
            modulus: None,
            rng: None,
            miller_rabin_iterations: DEFAULT_MR_ITERATIONS,
        }
    }
}

impl KeyPairBuilder {
    pub fn with_exponent(&mut self, e: BigInt) -> &mut Self {
        self.exponent = Some(e);
        self
    }
    pub fn with_modulus(&mut self, p: BigInt, q: BigInt) -> &mut Self {
        self.modulus = Some((p, q));
        self
    }
    pub fn with_rng(&mut self, rng: Box<dyn RsaCsprng>) -> &mut Self {
        self.rng = Some(rng);
        self
    }
    pub fn with_iterations(&mut self, iterations: usize) -> &mut Self {
        self.miller_rabin_iterations = iterations;
        self
    }

    /// Consumes fields
    /// TODO:
    /// - prime-gen multithreading?
    pub fn create_keypair(&mut self) -> Result<KeyPair, RsaError> {
        let mut rng = self.rng.take().unwrap_or(Box::new(StdRng::from_entropy()));
        let mr_iterations = self.miller_rabin_iterations;

        let modulus = self.modulus.take().unwrap_or_else(|| {
            (
                generate_candidate_prime(&mut rng, mr_iterations),
                generate_candidate_prime(&mut rng, mr_iterations),
            )
        });

        let lambda = carmichael_totient(&modulus.0, &modulus.1);

        let exponent = self.exponent.take().unwrap_or_else(|| {
            // compute carmichael totient = lambda
            // look for values of e that are coprime to lambda
            let three = BigInt::ZERO + 3u32;
            let one = BigInt::ZERO + 1u32;
            let mut e = rng.gen_bigint_range(&three, &lambda);

            // pick a random spot, look locally till we find something coprime to lambda
            // if we reach lambda then start over
            // should be faster than just generating randomly over and over
            while e.gcd(&lambda) != one {
                e.inc();

                if e == lambda {
                    e = rng.gen_bigint_range(&three, &lambda);
                }
            }

            e
        });

        let secret = exponent.modinv(&lambda).ok_or_else(|| {
            RsaError::new(
                RsaErrorKind::OptionsError,
                format!(
                    "unable to find modular inverse of {} with respect to {}.",
                    exponent, lambda
                ),
            )
        })?;

        let n = &modulus.0 * &modulus.1;

        let pk = RsaPublicKey::new(exponent.clone(), n.clone());
        let sk = RsaPrivateKey::with_values(n, exponent, secret, modulus.0, modulus.1)?;

        Ok(KeyPair {
            public_key: pk,
            private_key: sk,
        })
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct KeyPair {
    pub public_key: RsaPublicKey,
    pub private_key: RsaPrivateKey,
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct RsaPublicKey {
    pub modulus: BigInt,
    pub public_exponent: BigInt,
}

#[derive(Clone, Debug, Eq, PartialEq)]
/// [See source](https://datatracker.ietf.org/doc/html/rfc3447#appendix-A)
pub struct RsaPrivateKey {
    pub version: u8,
    pub modulus: BigInt,
    pub public_exponent: BigInt,
    pub private_exponent: BigInt,
    pub prime1: BigInt,
    pub prime2: BigInt,
    pub exponent1: BigInt,
    pub exponent2: BigInt,
    pub coefficient: BigInt,
}

impl RsaPublicKey {
    pub fn new(e: BigInt, n: BigInt) -> Self {
        Self {
            public_exponent: e,
            modulus: n,
        }
    }
}

impl RsaPrivateKey {
    pub fn new(
        version: u8,
        modulus: BigInt,
        public_exponent: BigInt,
        private_exponent: BigInt,
        prime1: BigInt,
        prime2: BigInt,
        exponent1: BigInt,
        exponent2: BigInt,
        coefficient: BigInt,
    ) -> Self {
        Self {
            version,
            modulus,
            public_exponent,
            private_exponent,
            prime1,
            prime2,
            exponent1,
            exponent2,
            coefficient,
        }
    }

    fn with_values(
        n: BigInt,
        e: BigInt,
        d: BigInt,
        p: BigInt,
        q: BigInt,
    ) -> Result<Self, RsaError> {
        let p1 = &p - 1u32;
        let q1 = &q - 1u32;

        let dp = &d % &p1;
        let dq = &d % &q1;

        let qinv = q.modinv(&p).ok_or_else(|| {
            RsaError::new(
                RsaErrorKind::OptionsError,
                format!(
                    "Unable to compute modular inverse of {} with respect to {}.",
                    q, p
                ),
            )
        })?;

        Ok(Self {
            version: RSA_VERSION,
            modulus: n,
            public_exponent: e,
            private_exponent: d,
            prime1: p,
            prime2: q,
            exponent1: dp,
            exponent2: dq,
            coefficient: qinv,
        })
    }
}
